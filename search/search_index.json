{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Notes \u00b6 A personal - python learning note. Reference https://www.w3schools.com/python/python_intro.asp https://book.pythontips.com/en/latest/ https://diveintopython3.problemsolving.io/index.html","title":"Home"},{"location":"#python-notes","text":"A personal - python learning note. Reference https://www.w3schools.com/python/python_intro.asp https://book.pythontips.com/en/latest/ https://diveintopython3.problemsolving.io/index.html","title":"Python Notes"},{"location":"basic/","text":"[toc] Python Data Types \u00b6 Text Type: str Numeric Types: int, float, complex Sequence Types: list, tuple, range Mapping Type: dict Set Types: set, frozenset Boolean Type: bool Binary Types: bytes, bytearray, memoryview Example Data Type x = \"Hello World\" str x = 20 int x = 20.5 float x = 1j complex x = [\"apple\", \"banana\", \"cherry\"] list x = (\"apple\", \"banana\", \"cherry\") tuple x = range(6) range x = {\"name\" : \"John\", \"age\" : 36} dict x = {\"apple\", \"banana\", \"cherry\"} set x = frozenset({\"apple\", \"banana\", \"cherry\"}) frozenset x = True bool x = b\"Hello\" bytes x = bytearray(5) bytearray x = memoryview(bytes(5)) memoryview \\n (backslash n) a new line character Build in Function \u00b6 zip() Function \u00b6 a = (\"John\", \"Charles\", \"Mike\") b = (\"Jenny\", \"Christy\", \"Monica\", \"Vicky\") x = zip(a, b) name = [ \"Manjeet\", \"Nikhil\", \"Shambhavi\", \"Astha\" ] roll_no = [ 4, 1, 3, 2 ] marks = [ 40, 50, 60, 70 ] mapped = zip(name, roll_no, marks) # converting values to print as set mapped = set(mapped) # printing resultant values print (\"The zipped result is : \",end=\"\") print (mapped) # output The zipped result is : {('Shambhavi', 3, 60), ('Astha', 2, 70), ('Manjeet', 4, 40), ('Nikhil', 1, 50)} numbers = [1, 2, 3] letters = ['a', 'b', 'c'] zipped = zip(numbers, letters) type(zipped) # output <class 'zip'> # zip() function returns an iterator, use list() to consume the iterator list(zipped) # output [(1, 'a'), (2, 'b'), (3, 'c')] File Handling \u00b6 Directory \u00b6 os.getcwd() function to get the current working directory os.chdir() function to change the current working directory. os.path.join() function constructs a pathname out of one or more partial pathnames. os.path.expanduser() function will expand a pathname that uses ~ to represent the current user\u2019s home directory. glob \u00b6 glob module is another tool in the Python standard library The glob module uses shell-like wildcards. File Open \u00b6 open() : Reading and Writing Files \"r\" - Read - Default value. Opens a file for reading, error if the file does not exist \"a\" - Append - Opens a file for appending, creates the file if it does not exist \"w\" - Write - Opens a file for writing, creates the file if it does not exist \"x\" - Create - Creates the specified file, returns an error if the file exists f = open('workfile', 'w') Read Only Parts of the File read() Read Files \u00b6 f = open(\"demofile.txt\", \"r\") print(f.read()) Read Lines \u00b6 It is a good practice to always close the file when you are done with it. f = open(\"demofile.txt\", \"r\") print(f.readline()) f.close() File Write \u00b6 Existing File \u00b6 \"a\" - Append - will append to the end of the file \"w\" - Write - will overwrite any existing content Create a New File \u00b6 \"x\" - Create - will create a file, returns an error if the file exist \"a\" - Append - will create a file if the specified file does not exist \"w\" - Write - will create a file if the specified file does not exist seek(0) : Move the read/write location to the beginning of the file. os.path.basename() and os.path.dirname()? Both functions use the os.path.split(path) function to split the pathname path into a pair; (head, tail). The os.path.dirname(path) function returns the head of the path. E.g.: The dirname of '/foo/bar/item' is '/foo/bar'. The os.path.basename(path) function returns the tail of the path. E.g.: The basename of '/foo/bar/item' returns 'item' RegEx \u00b6 RegEx : regular expressions in Python with the re module RegEx Functions \u00b6 Function Description findall Returns a list containing all matches search Returns a Match object if there is a match anywhere in the string split Returns a list where the string has been split at each match sub Replaces one or many matches with a string Metacharacters \u00b6 Character Description Example [] A set of characters \"[a-m]\" \\ Signals a special sequence (can also be used to escape special characters) \"\\d\" . Any character (except newline character) \"he..o\" ^ Starts with \"^hello\" $ Ends with \"world$\" * Zero or more occurrences \"aix*\" + One or more occurrences \"aix+\" {} Exactly the specified number of occurrences \"al{2}\" | Either or \"falls|stays\" () Capture and group The findall() function returns a list containing all matches. import re txt = \"The rain in Spain\" x = re.findall(\"ai\", txt) print(x)","title":"Basic"},{"location":"basic/#python-data-types","text":"Text Type: str Numeric Types: int, float, complex Sequence Types: list, tuple, range Mapping Type: dict Set Types: set, frozenset Boolean Type: bool Binary Types: bytes, bytearray, memoryview Example Data Type x = \"Hello World\" str x = 20 int x = 20.5 float x = 1j complex x = [\"apple\", \"banana\", \"cherry\"] list x = (\"apple\", \"banana\", \"cherry\") tuple x = range(6) range x = {\"name\" : \"John\", \"age\" : 36} dict x = {\"apple\", \"banana\", \"cherry\"} set x = frozenset({\"apple\", \"banana\", \"cherry\"}) frozenset x = True bool x = b\"Hello\" bytes x = bytearray(5) bytearray x = memoryview(bytes(5)) memoryview \\n (backslash n) a new line character","title":"Python Data Types"},{"location":"basic/#build-in-function","text":"","title":"Build in Function"},{"location":"basic/#zip-function","text":"a = (\"John\", \"Charles\", \"Mike\") b = (\"Jenny\", \"Christy\", \"Monica\", \"Vicky\") x = zip(a, b) name = [ \"Manjeet\", \"Nikhil\", \"Shambhavi\", \"Astha\" ] roll_no = [ 4, 1, 3, 2 ] marks = [ 40, 50, 60, 70 ] mapped = zip(name, roll_no, marks) # converting values to print as set mapped = set(mapped) # printing resultant values print (\"The zipped result is : \",end=\"\") print (mapped) # output The zipped result is : {('Shambhavi', 3, 60), ('Astha', 2, 70), ('Manjeet', 4, 40), ('Nikhil', 1, 50)} numbers = [1, 2, 3] letters = ['a', 'b', 'c'] zipped = zip(numbers, letters) type(zipped) # output <class 'zip'> # zip() function returns an iterator, use list() to consume the iterator list(zipped) # output [(1, 'a'), (2, 'b'), (3, 'c')]","title":"zip() Function"},{"location":"basic/#file-handling","text":"","title":"File Handling"},{"location":"basic/#directory","text":"os.getcwd() function to get the current working directory os.chdir() function to change the current working directory. os.path.join() function constructs a pathname out of one or more partial pathnames. os.path.expanduser() function will expand a pathname that uses ~ to represent the current user\u2019s home directory.","title":"Directory"},{"location":"basic/#glob","text":"glob module is another tool in the Python standard library The glob module uses shell-like wildcards.","title":"glob"},{"location":"basic/#file-open","text":"open() : Reading and Writing Files \"r\" - Read - Default value. Opens a file for reading, error if the file does not exist \"a\" - Append - Opens a file for appending, creates the file if it does not exist \"w\" - Write - Opens a file for writing, creates the file if it does not exist \"x\" - Create - Creates the specified file, returns an error if the file exists f = open('workfile', 'w') Read Only Parts of the File read()","title":"File Open"},{"location":"basic/#read-files","text":"f = open(\"demofile.txt\", \"r\") print(f.read())","title":"Read Files"},{"location":"basic/#read-lines","text":"It is a good practice to always close the file when you are done with it. f = open(\"demofile.txt\", \"r\") print(f.readline()) f.close()","title":"Read Lines"},{"location":"basic/#file-write","text":"","title":"File Write"},{"location":"basic/#existing-file","text":"\"a\" - Append - will append to the end of the file \"w\" - Write - will overwrite any existing content","title":"Existing File"},{"location":"basic/#create-a-new-file","text":"\"x\" - Create - will create a file, returns an error if the file exist \"a\" - Append - will create a file if the specified file does not exist \"w\" - Write - will create a file if the specified file does not exist seek(0) : Move the read/write location to the beginning of the file. os.path.basename() and os.path.dirname()? Both functions use the os.path.split(path) function to split the pathname path into a pair; (head, tail). The os.path.dirname(path) function returns the head of the path. E.g.: The dirname of '/foo/bar/item' is '/foo/bar'. The os.path.basename(path) function returns the tail of the path. E.g.: The basename of '/foo/bar/item' returns 'item'","title":"Create a New File"},{"location":"basic/#regex","text":"RegEx : regular expressions in Python with the re module","title":"RegEx"},{"location":"basic/#regex-functions","text":"Function Description findall Returns a list containing all matches search Returns a Match object if there is a match anywhere in the string split Returns a list where the string has been split at each match sub Replaces one or many matches with a string","title":"RegEx Functions"},{"location":"basic/#metacharacters","text":"Character Description Example [] A set of characters \"[a-m]\" \\ Signals a special sequence (can also be used to escape special characters) \"\\d\" . Any character (except newline character) \"he..o\" ^ Starts with \"^hello\" $ Ends with \"world$\" * Zero or more occurrences \"aix*\" + One or more occurrences \"aix+\" {} Exactly the specified number of occurrences \"al{2}\" | Either or \"falls|stays\" () Capture and group The findall() function returns a list containing all matches. import re txt = \"The rain in Spain\" x = re.findall(\"ai\", txt) print(x)","title":"Metacharacters"},{"location":"excel/","text":"How to Use Math AutoCorrect in Excel \u00b6 Summary Use Math AutoCorrect Outside of Math Regions in Excel Excel does not have Word's native option available within the Excel Options \u25ba Proofing \u25ba AutoCorrect Options \u25ba Math AutoCorrect for Use Math AutoCorrect rules outside of math regions . Likewise, much of the VBA functionality within Excel's VBE for the OMathAutoCorrect or OMathAutoCorrectEntries collection objects has been disabled. When Excel is within its own math editor, a different interface is being exchanged with and all symbols can be properly displayed but using AutoCorrect for the math symbols in regular worksheet operations is not available. Intended for Excel 2010 and 2013 (and other Office programs of the same versions) Details How to get Math AutoCorrect into Everyday Excel Worksheet Operations In my (admittedly uninformed) opinion, Excel's separation of standard and mathematical autocorrect and the subsequent crippling of the latter most likely has to do with several common math symbols being used for reserved purposes within Excel. The single quote (e.g. tick or ASCII 0\u00d7039) character being the most obvious one as it is used to force Excel to consider a number or date as text when used as a prefix. Suffice to say that there are legitimate reasons why the decision to isolate Excel's Math AutoCorrect was made while Word's was not. This just means that we have to work around the limitation and accept any shortcomings. While Excel's VBA use of the OMathAutoCorrect object is somewhat crippled, the equivalent VBA in Word is not. If we take all of the entries from the OMathAutoCorrectEntries collection and convert them as additions to the standard AutoCorrectEntries collection, then they will be available within all Office programs including Excel. The end results in each of the Office programs may vary. Normalizing the Math AutoCorrect Entries with a Macro Close Excel and all other Office programs then open Word to a new blank document and tap Alt+F11 to enter the VBE. Use the pull-down menus to Insert \u25ba Module (or Alt+I, M). Paste the following into the new pane titled something like Normal - NewMacros (Code) or Normal - Module1 (Code) . Sub Normalize_Math_AutoCorrect_Entries() Dim acm As Long, ac As Long, yn As Long, cACEs As AutoCorrectEntries Set cACEs = Application.AutoCorrect.Entries With Application.OMathAutoCorrect .UseOutsideOMath = False 'no longer necessary For acm = 1 To .Entries.Count yn = vbYes For ac = 1 To cACEs.Count If cACEs(ac).Name = .Entries(acm).Name Then yn = MsgBox(cACEs(ac).Name & \" is currently assigned to \" & cACEs(ac).Value & _ Chr(46) & Chr(10) & Chr(10) & \"Are you sure you want to replace it?\", _ vbYesNo + vbQuestion, \"Duplication\") If yn = vbYes Then cACEs(ac).Delete Exit For End If Next ac If yn = vbYes Then Application.AutoCorrect.Entries.Add Name:=.Entries(acm).Name, _ \u200b Value:=.Entries(acm).Value \u200b End If \u200b Next acm End With Set cACEs = Nothing End Sub With that in place, tap Alt+Q to return to your blank document. Tap Alt+F8 to open the Macros dialog and run the macro. If a duplicate entry is encountered, the process will be paused and you will be presented with something like the following. ![Image](figures/2908ba3f-7915-4cb4-8286-14d47a76772a) Note that I have chosen to demonstrate one duplication that can actually be displayed. Many of the Unicode characters will only be represented by a ? since a standard VBA message box cannot display Unicode. This does not mean that the symbol will be added incorrectly; like Excel this is simply a display limitation. Accept or reject the overwrites. Anything not already found within the standard AutoCorrectEntries collection will be added without asking. When this process is complete, all of the OMathAutoCorrect entries will have been normalized as standard AutoCorrect entries. If you open Excel, they should be available immediately. Here are some before and after screenshots first initiating the auto-correction process by typing the keyword then typing the space that forces the auto-correction event after \\beta. \u200b That is all there is to it. By converting the special Math AutoCorrect Entries to standard ones, the limitation on using the special math symbol through auto-correction has been bypassed. References I've prepared a full listing of the Math AutoCorrect symbols on my OneDrive here for you to reference. Excel_2013_OMathAutoCorrectEntries.xlsx On a related note, I wrote a local Wiki article a while back on a similar topic on the use of stylized fractions within Office programs through additions to the standard AutoCorrect collection. Here is a link to that: Styled Fractions in Windows","title":"Excel"},{"location":"excel/#how-to-use-math-autocorrect-in-excel","text":"Summary Use Math AutoCorrect Outside of Math Regions in Excel Excel does not have Word's native option available within the Excel Options \u25ba Proofing \u25ba AutoCorrect Options \u25ba Math AutoCorrect for Use Math AutoCorrect rules outside of math regions . Likewise, much of the VBA functionality within Excel's VBE for the OMathAutoCorrect or OMathAutoCorrectEntries collection objects has been disabled. When Excel is within its own math editor, a different interface is being exchanged with and all symbols can be properly displayed but using AutoCorrect for the math symbols in regular worksheet operations is not available. Intended for Excel 2010 and 2013 (and other Office programs of the same versions) Details How to get Math AutoCorrect into Everyday Excel Worksheet Operations In my (admittedly uninformed) opinion, Excel's separation of standard and mathematical autocorrect and the subsequent crippling of the latter most likely has to do with several common math symbols being used for reserved purposes within Excel. The single quote (e.g. tick or ASCII 0\u00d7039) character being the most obvious one as it is used to force Excel to consider a number or date as text when used as a prefix. Suffice to say that there are legitimate reasons why the decision to isolate Excel's Math AutoCorrect was made while Word's was not. This just means that we have to work around the limitation and accept any shortcomings. While Excel's VBA use of the OMathAutoCorrect object is somewhat crippled, the equivalent VBA in Word is not. If we take all of the entries from the OMathAutoCorrectEntries collection and convert them as additions to the standard AutoCorrectEntries collection, then they will be available within all Office programs including Excel. The end results in each of the Office programs may vary. Normalizing the Math AutoCorrect Entries with a Macro Close Excel and all other Office programs then open Word to a new blank document and tap Alt+F11 to enter the VBE. Use the pull-down menus to Insert \u25ba Module (or Alt+I, M). Paste the following into the new pane titled something like Normal - NewMacros (Code) or Normal - Module1 (Code) . Sub Normalize_Math_AutoCorrect_Entries() Dim acm As Long, ac As Long, yn As Long, cACEs As AutoCorrectEntries Set cACEs = Application.AutoCorrect.Entries With Application.OMathAutoCorrect .UseOutsideOMath = False 'no longer necessary For acm = 1 To .Entries.Count yn = vbYes For ac = 1 To cACEs.Count If cACEs(ac).Name = .Entries(acm).Name Then yn = MsgBox(cACEs(ac).Name & \" is currently assigned to \" & cACEs(ac).Value & _ Chr(46) & Chr(10) & Chr(10) & \"Are you sure you want to replace it?\", _ vbYesNo + vbQuestion, \"Duplication\") If yn = vbYes Then cACEs(ac).Delete Exit For End If Next ac If yn = vbYes Then Application.AutoCorrect.Entries.Add Name:=.Entries(acm).Name, _ \u200b Value:=.Entries(acm).Value \u200b End If \u200b Next acm End With Set cACEs = Nothing End Sub With that in place, tap Alt+Q to return to your blank document. Tap Alt+F8 to open the Macros dialog and run the macro. If a duplicate entry is encountered, the process will be paused and you will be presented with something like the following. ![Image](figures/2908ba3f-7915-4cb4-8286-14d47a76772a) Note that I have chosen to demonstrate one duplication that can actually be displayed. Many of the Unicode characters will only be represented by a ? since a standard VBA message box cannot display Unicode. This does not mean that the symbol will be added incorrectly; like Excel this is simply a display limitation. Accept or reject the overwrites. Anything not already found within the standard AutoCorrectEntries collection will be added without asking. When this process is complete, all of the OMathAutoCorrect entries will have been normalized as standard AutoCorrect entries. If you open Excel, they should be available immediately. Here are some before and after screenshots first initiating the auto-correction process by typing the keyword then typing the space that forces the auto-correction event after \\beta. \u200b That is all there is to it. By converting the special Math AutoCorrect Entries to standard ones, the limitation on using the special math symbol through auto-correction has been bypassed. References I've prepared a full listing of the Math AutoCorrect symbols on my OneDrive here for you to reference. Excel_2013_OMathAutoCorrectEntries.xlsx On a related note, I wrote a local Wiki article a while back on a similar topic on the use of stylized fractions within Office programs through additions to the standard AutoCorrect collection. Here is a link to that: Styled Fractions in Windows","title":"How to Use Math AutoCorrect in Excel"},{"location":"itermediate/","text":"Collections Counter namedtuple Comprehensions list comprehensions dict comprehensions set comprehensions generator comprehensions Decorators Defining functions within functions: Returning functions from within functions: Giving a function as an argument to another function: Writing your first decorator: Use-cases: Logging Decorators with Arguments Nesting a Decorator Within a Function Decorator Classes Enumerate File Handling Ignore Rows Generators Iterable Iterator Iteration Generators {#generators-1} Lambdas Typing Collections \u00b6 Python ships with a module that contains a number of container data types called Collections: Counter namedtuple Counter \u00b6 Counter allows us to count the occurrences of a particular item. For instance it can be used to count the number of individual favourite colours: from collections import Counter colours = ( ('Jack', 'Yellow'), ('Bob', 'Blue'), ('Alice', 'Green'), ('Simon', 'Black'), ('Bob', 'Red'), ('Alice', 'Silver'), ) favs = Counter(name for name, colour in colours) print(favs) We can also count the most common lines in a file using it. For example: with open('filename', 'rb') as f: line_count = Counter(f) print(line_count) namedtuple \u00b6 You might already be acquainted with tuples. A tuple is basically a immutable list which allows you to store a sequence of values separated by commas. They are just like lists but have a few key differences. The major one is that unlike lists, you can not reassign an item in a tuple . In order to access the value in a tuple you use integer indexes like: man = ('Ali', 30) print(man[0]) # Output: Ali Well, so now what are namedtuples ? They turn tuples into convenient containers for simple tasks. With namedtuples you don\\'t have to use integer indexes for accessing members of a tuple. You can think of namedtuples like dictionaries but unlike dictionaries they are immutable. from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") print(perry) # Output: Animal(name='perry', age=31, type='cat') print(perry.name) # Output: 'perry' You can now see that we can access members of a tuple just by their name using a . . Let's dissect it a little more. A named tuple has two required arguments. They are the tuple name and the tuple field_names. In the above example our tuple name was 'Animal' and the tuple field_names were 'name', 'age' and 'type'. Namedtuple makes your tuples self-document . You can easily understand what is going on by having a quick glance at your code. And as you are not bound to use integer indexes to access members of a tuple, it makes it more easy to maintain your code. Moreover, as namedtuple instances do not have per-instance dictionaries , they are lightweight and require no more memory than regular tuples. This makes them faster than dictionaries. However, do remember that as with tuples, attributes in namedtuples are immutable . It means that this would not work: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") perry.age = 42 # Output: Traceback (most recent call last): # File \"\", line 1, in # AttributeError: can't set attribute You should use named tuples to make your code self-documenting. They are backwards compatible with normal tuples . It means that you can use integer indexes with namedtuples as well: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") print(perry[0]) # Output: perry Last but not the least, you can convert a namedtuple to a dictionary. Like this: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"Perry\", age=31, type=\"cat\") print(perry._asdict()) # Output: OrderedDict([('name', 'Perry'), ('age', 31), ... Comprehensions \u00b6 Comprehensions are constructs that allow sequences to be built from other sequences. Several types of comprehensions are supported: list comprehensions dictionary comprehensions set comprehensions generator comprehensions list comprehensions \u00b6 List comprehensions provide a short and concise way to create lists. It consists of square brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expressions can be anything, meaning you can put in all kinds of objects in lists. The result would be a new list made after the evaluation of the expression in context of the if and for clauses. Blueprint variable = [out_exp for out_exp in input_list if out_exp == 2] Here is a short example: multiples = [i for i in range(30) if i % 3 == 0] print(multiples) # Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27] This can be really useful to make lists quickly. It is even preferred by some instead of the filter function. List comprehensions really shine when you want to supply a list to a method or function to make a new list by appending to it in each iteration of the for loop. For instance you would usually do something like this: squared = [] for x in range(10): squared.append(x**2) You can simplify it using list comprehensions. For example: squared = [x**2 for x in range(10)] dict comprehensions \u00b6 They are used in a similar way. Here is an example which I found recently: mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3} mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys() } # mcase_frequency == {'a': 17, 'z': 3, 'b': 34} In the above example we are combining the values of keys which are same but in different typecase. I personally do not use dict comprehensions a lot. You can also quickly switch keys and values of a dictionary: {v: k for k, v in some_dict.items()} set comprehensions \u00b6 They are also similar to list comprehensions. The only difference is that they use braces {} . Here is an example: squared = {x**2 for x in [1, 1, 2]} print(squared) # Output: {1, 4} generator comprehensions \u00b6 They are also similar to list comprehensions. The only difference is that they don't allocate memory for the whole list but generate one item at a time, thus more memory efficient. multiples_gen = (i for i in range(30) if i % 3 == 0) print(multiples_gen) # Output: <generator object <genexpr> at 0x7fdaa8e407d8> for x in multiples_gen: print(x) # Outputs numbers Decorators \u00b6 Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated. Defining functions within functions: \u00b6 In Python we can define functions inside other functions: def hi(name=\"bigriver\"): print(\"now you are inside the hi() function\") def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" print(greet()) print(welcome()) print(\"now you are back in the hi() function\") hi() #output:now you are inside the hi() function # now you are in the greet() function # now you are in the welcome() function # now you are back in the hi() function # This shows that whenever you call hi(), greet() and welcome() # are also called. However the greet() and welcome() functions # are not available outside the hi() function e.g: greet() #outputs: NameError: name 'greet' is not defined So now we know that we can define functions in other functions. In other words: we can make nested functions. Now you need to learn one more thing, that functions can return functions too. Returning functions from within functions: \u00b6 It is not necessary to execute a function within another function, we can return it as an output as well: def hi(name=\"bigriver\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"bigriver\": return greet else: return welcome a = hi() print(a) #outputs: <function greet at 0x7f2143c01500> #This clearly shows that `a` now points to the greet() function in hi() #Now try this print(a()) #outputs: now you are in the greet() function Just take a look at the code again. In the if else clause we are returning greet and welcome , not greet() and welcome() . Why is that? It's because when you put a pair of parentheses after it, the function gets executed; whereas if you don't put parenthesis after it, then it can be passed around and can be assigned to other variables without executing it. Did you get it? Let me explain it in a little bit more detail. When we write a = hi() , hi() gets executed and because the name is bigriver by default, the function greet is returned. If we change the statement to a = hi(name = \"ali\") then the welcome function will be returned. We can also do print hi()() which outputs now you are in the greet() function . Giving a function as an argument to another function: \u00b6 def hi(): return \"hi bigriver!\" def doSomethingBeforeHi(func): print(\"I am doing some boring work before executing hi()\") print(func()) doSomethingBeforeHi(hi) #outputs:I am doing some boring work before executing hi() # hi bigriver! Now you have all the required knowledge to learn what decorators really are. Decorators let you execute code before and after a function. Writing your first decorator: \u00b6 In the last example we actually made a decorator! Let\\'s modify the previous decorator and make a little bit more usable program: def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction def a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\") a_function_requiring_decoration() #outputs: \"I am the function which needs some decoration to remove my foul smell\" a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) #now a_function_requiring_decoration is wrapped by wrapTheFunction() a_function_requiring_decoration() #outputs:I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() Did you get it? We just applied the previously learned principles. This is exactly what the decorators do in Python! They wrap a function and modify its behaviour in one way or another. Now you might be wondering why we did not use the @ anywhere in our code? That is just a short way of making up a decorated function. Here is how we could have run the previous code sample using @. @a_new_decorator def a_function_requiring_decoration(): \"\"\"Hey you! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\") a_function_requiring_decoration() #outputs: I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() #the @a_new_decorator is just a short way of saying: a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) I hope you now have a basic understanding of how decorators work in Python. Now there is one problem with our code. If we run: print(a_function_requiring_decoration.__name__) # Output: wrapTheFunction That's not what we expected! Its name is \"a_function_requiring_decoration\". Well, our function was replaced by wrapTheFunction. It overrode the name and docstring of our function. Luckily, Python provides us a simple function to solve this problem and that is functools.wraps . Let's modify our previous example to use functools.wraps : from functools import wraps def a_new_decorator(a_func): @wraps(a_func) def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction @a_new_decorator def a_function_requiring_decoration(): \"\"\"Hey yo! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\") print(a_function_requiring_decoration.__name__) # Output: a_function_requiring_decoration Now that is much better. Let\\'s move on and learn some use-cases of decorators. Blueprint: from functools import wraps def decorator_name(f): @wraps(f) def decorated(*args, **kwargs): if not can_run: return \"Function will not run\" return f(*args, **kwargs) return decorated @decorator_name def func(): return(\"Function is running\") can_run = True print(func()) # Output: Function is running can_run = False print(func()) # Output: Function will not run Note: @wraps takes a function to be decorated and adds the functionality of copying over the function name, docstring, arguments list, etc. This allows us to access the pre-decorated function\\'s properties in the decorator. Use-cases: \u00b6 Now let\\'s take a look at the areas where decorators really shine and their usage makes something really easy to manage. Authorization \\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~ Decorators can help to check whether someone is authorized to use an endpoint in a web application. They are extensively used in Flask web framework and Django. Here is an example to employ decorator based authentication: Example : from functools import wraps def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated Logging \u00b6 Logging is another area where the decorators shine. Here is an example: from functools import wraps def logit(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + \" was called\") return func(*args, **kwargs) return with_logging @logit def addition_func(x): \"\"\"Do some math.\"\"\" return x + x result = addition_func(4) # Output: addition_func was called I am sure you are already thinking about some clever uses of decorators. Decorators with Arguments \u00b6 Come to think of it, isn't @wraps also a decorator? But, it takes an argument like any normal function can do. So, why can\\'t we do that too? This is because when you use the @my_decorator syntax, you are applying a wrapper function with a single function as a parameter. Remember, everything in Python is an object, and this includes functions! With that in mind, we can write a function that returns a wrapper function. Nesting a Decorator Within a Function \u00b6 Let's go back to our logging example, and create a wrapper which lets us specify a logfile to output to. from functools import wraps def logit(logfile='out.log'): def logging_decorator(func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + \" was called\" print(log_string) # Open the logfile and append with open(logfile, 'a') as opened_file: # Now we log to the specified logfile opened_file.write(log_string + '\\n') return func(*args, **kwargs) return wrapped_function return logging_decorator @logit() def myfunc1(): pass myfunc1() # Output: myfunc1 was called # A file called out.log now exists, with the above string @logit(logfile='func2.log') def myfunc2(): pass myfunc2() # Output: myfunc2 was called # A file called func2.log now exists, with the above string Decorator Classes \u00b6 Now we have our logit decorator in production, but when some parts of our application are considered critical, failure might be something that needs more immediate attention. Let\\'s say sometimes you want to just log to a file. Other times you want an email sent, so the problem is brought to your attention, and still keep a log for your own records. This is a case for using inheritence, but so far we\\'ve only seen functions being used to build decorators. Luckily, classes can also be used to build decorators. So, let\\'s rebuild logit as a class instead of a function. class logit(object): _logfile = 'out.log' def __init__(self, func): self.func = func def __call__(self, *args): log_string = self.func.__name__ + \" was called\" print(log_string) # Open the logfile and append with open(self._logfile, 'a') as opened_file: # Now we log to the specified logfile opened_file.write(log_string + '\\n') # Now, send a notification self.notify() # return base func return self.func(*args) def notify(self): # logit only logs, no more pass This implementation has an additional advantage of being much cleaner than the nested function approach, and wrapping a function still will use the same syntax as before: logit._logfile = 'out2.log' # if change log file @logit def myfunc1(): pass myfunc1() # Output: myfunc1 was called Now, let's subclass logit to add email functionality (though this topic will not be covered here). class email_logit(logit): ''' A logit implementation for sending emails to admins when the function is called. ''' def __init__(self, email='admin@myproject.com', *args, **kwargs): self.email = email super(email_logit, self).__init__(*args, **kwargs) def notify(self): # Send an email to self.email # Will not be implemented here pass From here, @email_logit works just like @logit but sends an email to the admin in addition to logging. Enumerate \u00b6 Enumerate is a built-in function of Python. Its usefulness can not be summarized in a single line. Yet most of the newcomers and even some advanced programmers are unaware of it. It allows us to loop over something and have an automatic counter. Here is an example: for counter, value in enumerate(some_list): print(counter, value) And there is more! enumerate also accepts an optional argument which makes it even more useful. my_list = ['apple', 'banana', 'grapes', 'pear'] for c, value in enumerate(my_list, 1): print(c, value) # Output: # 1 apple # 2 banana # 3 grapes # 4 pear The optional argument allows us to tell enumerate from where to start the index. You can also create tuples containing the index and list item using a list. Here is an example: my_list = ['apple', 'banana', 'grapes', 'pear'] counter_list = list(enumerate(my_list, 1)) print(counter_list) # Output: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')] File Handling \u00b6 Ignore Rows \u00b6 skip header row with open(fname) as f: next(f) for line in f: #do something ignore blank lines def nonblank_lines(f): for l in f: line = l.rstrip() if line: yield line with open(filename) as f_in: for line in nonblank_lines(f_in): # Stuff Generators \u00b6 First lets understand iterators. According to Wikipedia, an iterator is an object that enables a programmer to traverse a container, particularly lists. However, an iterator performs traversal and gives access to data elements in a container, but does not perform iteration. You might be confused so lets take it a bit slow. There are three parts namely: Iterable Iterator Iteration All of these parts are linked to each other. We will discuss them one by one and later talk about generators. Iterable \u00b6 An iterable is any object in Python which has an __iter__ or a __getitem__ method defined which returns an iterator or can take indexes (You can read more about them here ). In short an iterable is any object which can provide us with an iterator . So what is an iterator ? Iterator \u00b6 An iterator is any object in Python which has a next (Python2) or __next__ method defined. That\\'s it. That\\'s an iterator. Now let\\'s understand iteration . Iteration \u00b6 In simple words it is the process of taking an item from something e.g a list. When we use a loop to loop over something it is called iteration. It is the name given to the process itself. Now as we have a basic understanding of these terms let\\'s understand generators . Generators {#generators-1} \u00b6 Generators are iterators, but you can only iterate over them once. It's because they do not store all the values in memory, they generate the values on the fly. You use them by iterating over them, either with a \\'for\\' loop or by passing them to any function or construct that iterates. Most of the time generators are implemented as functions. However, they do not return a value, they yield it. Here is a simple example of a generator function: def generator_function(): for i in range(10): yield i for item in generator_function(): print(item) # Output: 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 It is not really useful in this case. Generators are best for calculating large sets of results (particularly calculations involving loops themselves) where you don\\'t want to allocate the memory for all results at the same time. Many Standard Library functions that return lists in Python 2 have been modified to return generators in Python 3 because generators require fewer resources. Here is an example generator which calculates fibonacci numbers: # generator version def fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + b Now we can use it like this: for x in fibon(1000000): print(x) This way we would not have to worry about it using a lot of resources. However, if we would have implemented it like this: def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result It would have used up all our resources while calculating a large input. We have discussed that we can iterate over generators only once but we haven\\'t tested it. Before testing it you need to know about one more built-in function of Python, next() . It allows us to access the next element of a sequence. So let\\'s test out our understanding: def generator_function(): for i in range(3): yield i gen = generator_function() print(next(gen)) # Output: 0 print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # StopIteration As we can see that after yielding all the values next() caused a StopIteration error. Basically this error informs us that all the values have been yielded. You might be wondering why we don\\'t get this error when using a for loop? Well the answer is simple. The for loop automatically catches this error and stops calling next . Did you know that a few built-in data types in Python also support iteration? Let\\'s check it out: my_string = \"Yasoob\" next(my_string) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # TypeError: str object is not an iterator Well that\\'s not what we expected. The error says that str is not an iterator. Well it\\'s right! It\\'s an iterable but not an iterator. This means that it supports iteration but we can\\'t iterate over it directly. So how would we iterate over it? It\\'s time to learn about one more built-in function, iter . It returns an iterator object from an iterable. While an int isn\\'t an iterable, we can use it on string! int_var = 1779 iter(int_var) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # TypeError: 'int' object is not iterable # This is because int is not iterable my_string = \"Yasoob\" my_iter = iter(my_string) print(next(my_iter)) # Output: 'Y' Now that is much better. I am sure that you loved learning about generators. Do bear it in mind that you can fully grasp this concept only when you use it. Make sure that you follow this pattern and use generators whenever they make sense to you. You won\\'t be disappointed! Lambdas \u00b6 Lambdas are one line functions. They are also known as anonymous functions in some other languages. Blueprint lambda argument: manipulate(argument) Example add = lambda x, y: x + y print(add(3, 5)) # Output: 8 Here are a few useful use cases for lambdas and just a few ways in which they are used in the wild: List sorting a = [(1, 2), (4, 1), (9, 10), (13, -3)] a.sort(key=lambda x: x[1]) print(a) # Output: [(13, -3), (4, 1), (1, 2), (9, 10)] Parallel sorting of lists data = zip(list1, list2) data = sorted(data) list1, list2 = map(lambda t: list(t), zip(*data)) class A(object): def foo(self, x): print \"executing foo(%s, %s)\" % (self, x) @classmethod def class_foo(cls, x): print \"executing class_foo(%s, %s)\" % (cls, x) @staticmethod def static_foo(x): print \"executing static_foo(%s)\" % x a = A() Typing \u00b6 typing : Support for type hints. def greeting(name: str) -> str: return 'Hello ' + name In the function greeting , the argument name is expected to be of type str and the return type str Subtypes are accepted as arguments typing.Union Union[X, Y] means either X or Y","title":"Itermediate"},{"location":"itermediate/#collections","text":"Python ships with a module that contains a number of container data types called Collections: Counter namedtuple","title":"Collections"},{"location":"itermediate/#counter","text":"Counter allows us to count the occurrences of a particular item. For instance it can be used to count the number of individual favourite colours: from collections import Counter colours = ( ('Jack', 'Yellow'), ('Bob', 'Blue'), ('Alice', 'Green'), ('Simon', 'Black'), ('Bob', 'Red'), ('Alice', 'Silver'), ) favs = Counter(name for name, colour in colours) print(favs) We can also count the most common lines in a file using it. For example: with open('filename', 'rb') as f: line_count = Counter(f) print(line_count)","title":"Counter"},{"location":"itermediate/#namedtuple","text":"You might already be acquainted with tuples. A tuple is basically a immutable list which allows you to store a sequence of values separated by commas. They are just like lists but have a few key differences. The major one is that unlike lists, you can not reassign an item in a tuple . In order to access the value in a tuple you use integer indexes like: man = ('Ali', 30) print(man[0]) # Output: Ali Well, so now what are namedtuples ? They turn tuples into convenient containers for simple tasks. With namedtuples you don\\'t have to use integer indexes for accessing members of a tuple. You can think of namedtuples like dictionaries but unlike dictionaries they are immutable. from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") print(perry) # Output: Animal(name='perry', age=31, type='cat') print(perry.name) # Output: 'perry' You can now see that we can access members of a tuple just by their name using a . . Let's dissect it a little more. A named tuple has two required arguments. They are the tuple name and the tuple field_names. In the above example our tuple name was 'Animal' and the tuple field_names were 'name', 'age' and 'type'. Namedtuple makes your tuples self-document . You can easily understand what is going on by having a quick glance at your code. And as you are not bound to use integer indexes to access members of a tuple, it makes it more easy to maintain your code. Moreover, as namedtuple instances do not have per-instance dictionaries , they are lightweight and require no more memory than regular tuples. This makes them faster than dictionaries. However, do remember that as with tuples, attributes in namedtuples are immutable . It means that this would not work: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") perry.age = 42 # Output: Traceback (most recent call last): # File \"\", line 1, in # AttributeError: can't set attribute You should use named tuples to make your code self-documenting. They are backwards compatible with normal tuples . It means that you can use integer indexes with namedtuples as well: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"perry\", age=31, type=\"cat\") print(perry[0]) # Output: perry Last but not the least, you can convert a namedtuple to a dictionary. Like this: from collections import namedtuple Animal = namedtuple('Animal', 'name age type') perry = Animal(name=\"Perry\", age=31, type=\"cat\") print(perry._asdict()) # Output: OrderedDict([('name', 'Perry'), ('age', 31), ...","title":"namedtuple"},{"location":"itermediate/#comprehensions","text":"Comprehensions are constructs that allow sequences to be built from other sequences. Several types of comprehensions are supported: list comprehensions dictionary comprehensions set comprehensions generator comprehensions","title":"Comprehensions"},{"location":"itermediate/#list-comprehensions","text":"List comprehensions provide a short and concise way to create lists. It consists of square brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expressions can be anything, meaning you can put in all kinds of objects in lists. The result would be a new list made after the evaluation of the expression in context of the if and for clauses. Blueprint variable = [out_exp for out_exp in input_list if out_exp == 2] Here is a short example: multiples = [i for i in range(30) if i % 3 == 0] print(multiples) # Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27] This can be really useful to make lists quickly. It is even preferred by some instead of the filter function. List comprehensions really shine when you want to supply a list to a method or function to make a new list by appending to it in each iteration of the for loop. For instance you would usually do something like this: squared = [] for x in range(10): squared.append(x**2) You can simplify it using list comprehensions. For example: squared = [x**2 for x in range(10)]","title":"list comprehensions"},{"location":"itermediate/#dict-comprehensions","text":"They are used in a similar way. Here is an example which I found recently: mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3} mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys() } # mcase_frequency == {'a': 17, 'z': 3, 'b': 34} In the above example we are combining the values of keys which are same but in different typecase. I personally do not use dict comprehensions a lot. You can also quickly switch keys and values of a dictionary: {v: k for k, v in some_dict.items()}","title":"dict comprehensions"},{"location":"itermediate/#set-comprehensions","text":"They are also similar to list comprehensions. The only difference is that they use braces {} . Here is an example: squared = {x**2 for x in [1, 1, 2]} print(squared) # Output: {1, 4}","title":"set comprehensions"},{"location":"itermediate/#generator-comprehensions","text":"They are also similar to list comprehensions. The only difference is that they don't allocate memory for the whole list but generate one item at a time, thus more memory efficient. multiples_gen = (i for i in range(30) if i % 3 == 0) print(multiples_gen) # Output: <generator object <genexpr> at 0x7fdaa8e407d8> for x in multiples_gen: print(x) # Outputs numbers","title":"generator comprehensions"},{"location":"itermediate/#decorators","text":"Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated.","title":"Decorators"},{"location":"itermediate/#defining-functions-within-functions","text":"In Python we can define functions inside other functions: def hi(name=\"bigriver\"): print(\"now you are inside the hi() function\") def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" print(greet()) print(welcome()) print(\"now you are back in the hi() function\") hi() #output:now you are inside the hi() function # now you are in the greet() function # now you are in the welcome() function # now you are back in the hi() function # This shows that whenever you call hi(), greet() and welcome() # are also called. However the greet() and welcome() functions # are not available outside the hi() function e.g: greet() #outputs: NameError: name 'greet' is not defined So now we know that we can define functions in other functions. In other words: we can make nested functions. Now you need to learn one more thing, that functions can return functions too.","title":"Defining functions within functions:"},{"location":"itermediate/#returning-functions-from-within-functions","text":"It is not necessary to execute a function within another function, we can return it as an output as well: def hi(name=\"bigriver\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"bigriver\": return greet else: return welcome a = hi() print(a) #outputs: <function greet at 0x7f2143c01500> #This clearly shows that `a` now points to the greet() function in hi() #Now try this print(a()) #outputs: now you are in the greet() function Just take a look at the code again. In the if else clause we are returning greet and welcome , not greet() and welcome() . Why is that? It's because when you put a pair of parentheses after it, the function gets executed; whereas if you don't put parenthesis after it, then it can be passed around and can be assigned to other variables without executing it. Did you get it? Let me explain it in a little bit more detail. When we write a = hi() , hi() gets executed and because the name is bigriver by default, the function greet is returned. If we change the statement to a = hi(name = \"ali\") then the welcome function will be returned. We can also do print hi()() which outputs now you are in the greet() function .","title":"Returning functions from within functions:"},{"location":"itermediate/#giving-a-function-as-an-argument-to-another-function","text":"def hi(): return \"hi bigriver!\" def doSomethingBeforeHi(func): print(\"I am doing some boring work before executing hi()\") print(func()) doSomethingBeforeHi(hi) #outputs:I am doing some boring work before executing hi() # hi bigriver! Now you have all the required knowledge to learn what decorators really are. Decorators let you execute code before and after a function.","title":"Giving a function as an argument to another function:"},{"location":"itermediate/#writing-your-first-decorator","text":"In the last example we actually made a decorator! Let\\'s modify the previous decorator and make a little bit more usable program: def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction def a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\") a_function_requiring_decoration() #outputs: \"I am the function which needs some decoration to remove my foul smell\" a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) #now a_function_requiring_decoration is wrapped by wrapTheFunction() a_function_requiring_decoration() #outputs:I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() Did you get it? We just applied the previously learned principles. This is exactly what the decorators do in Python! They wrap a function and modify its behaviour in one way or another. Now you might be wondering why we did not use the @ anywhere in our code? That is just a short way of making up a decorated function. Here is how we could have run the previous code sample using @. @a_new_decorator def a_function_requiring_decoration(): \"\"\"Hey you! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\") a_function_requiring_decoration() #outputs: I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() #the @a_new_decorator is just a short way of saying: a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) I hope you now have a basic understanding of how decorators work in Python. Now there is one problem with our code. If we run: print(a_function_requiring_decoration.__name__) # Output: wrapTheFunction That's not what we expected! Its name is \"a_function_requiring_decoration\". Well, our function was replaced by wrapTheFunction. It overrode the name and docstring of our function. Luckily, Python provides us a simple function to solve this problem and that is functools.wraps . Let's modify our previous example to use functools.wraps : from functools import wraps def a_new_decorator(a_func): @wraps(a_func) def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction @a_new_decorator def a_function_requiring_decoration(): \"\"\"Hey yo! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\") print(a_function_requiring_decoration.__name__) # Output: a_function_requiring_decoration Now that is much better. Let\\'s move on and learn some use-cases of decorators. Blueprint: from functools import wraps def decorator_name(f): @wraps(f) def decorated(*args, **kwargs): if not can_run: return \"Function will not run\" return f(*args, **kwargs) return decorated @decorator_name def func(): return(\"Function is running\") can_run = True print(func()) # Output: Function is running can_run = False print(func()) # Output: Function will not run Note: @wraps takes a function to be decorated and adds the functionality of copying over the function name, docstring, arguments list, etc. This allows us to access the pre-decorated function\\'s properties in the decorator.","title":"Writing your first decorator:"},{"location":"itermediate/#use-cases","text":"Now let\\'s take a look at the areas where decorators really shine and their usage makes something really easy to manage. Authorization \\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~ Decorators can help to check whether someone is authorized to use an endpoint in a web application. They are extensively used in Flask web framework and Django. Here is an example to employ decorator based authentication: Example : from functools import wraps def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated","title":"Use-cases:"},{"location":"itermediate/#logging","text":"Logging is another area where the decorators shine. Here is an example: from functools import wraps def logit(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + \" was called\") return func(*args, **kwargs) return with_logging @logit def addition_func(x): \"\"\"Do some math.\"\"\" return x + x result = addition_func(4) # Output: addition_func was called I am sure you are already thinking about some clever uses of decorators.","title":"Logging"},{"location":"itermediate/#decorators-with-arguments","text":"Come to think of it, isn't @wraps also a decorator? But, it takes an argument like any normal function can do. So, why can\\'t we do that too? This is because when you use the @my_decorator syntax, you are applying a wrapper function with a single function as a parameter. Remember, everything in Python is an object, and this includes functions! With that in mind, we can write a function that returns a wrapper function.","title":"Decorators with Arguments"},{"location":"itermediate/#nesting-a-decorator-within-a-function","text":"Let's go back to our logging example, and create a wrapper which lets us specify a logfile to output to. from functools import wraps def logit(logfile='out.log'): def logging_decorator(func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + \" was called\" print(log_string) # Open the logfile and append with open(logfile, 'a') as opened_file: # Now we log to the specified logfile opened_file.write(log_string + '\\n') return func(*args, **kwargs) return wrapped_function return logging_decorator @logit() def myfunc1(): pass myfunc1() # Output: myfunc1 was called # A file called out.log now exists, with the above string @logit(logfile='func2.log') def myfunc2(): pass myfunc2() # Output: myfunc2 was called # A file called func2.log now exists, with the above string","title":"Nesting a Decorator Within a Function"},{"location":"itermediate/#decorator-classes","text":"Now we have our logit decorator in production, but when some parts of our application are considered critical, failure might be something that needs more immediate attention. Let\\'s say sometimes you want to just log to a file. Other times you want an email sent, so the problem is brought to your attention, and still keep a log for your own records. This is a case for using inheritence, but so far we\\'ve only seen functions being used to build decorators. Luckily, classes can also be used to build decorators. So, let\\'s rebuild logit as a class instead of a function. class logit(object): _logfile = 'out.log' def __init__(self, func): self.func = func def __call__(self, *args): log_string = self.func.__name__ + \" was called\" print(log_string) # Open the logfile and append with open(self._logfile, 'a') as opened_file: # Now we log to the specified logfile opened_file.write(log_string + '\\n') # Now, send a notification self.notify() # return base func return self.func(*args) def notify(self): # logit only logs, no more pass This implementation has an additional advantage of being much cleaner than the nested function approach, and wrapping a function still will use the same syntax as before: logit._logfile = 'out2.log' # if change log file @logit def myfunc1(): pass myfunc1() # Output: myfunc1 was called Now, let's subclass logit to add email functionality (though this topic will not be covered here). class email_logit(logit): ''' A logit implementation for sending emails to admins when the function is called. ''' def __init__(self, email='admin@myproject.com', *args, **kwargs): self.email = email super(email_logit, self).__init__(*args, **kwargs) def notify(self): # Send an email to self.email # Will not be implemented here pass From here, @email_logit works just like @logit but sends an email to the admin in addition to logging.","title":"Decorator Classes"},{"location":"itermediate/#enumerate","text":"Enumerate is a built-in function of Python. Its usefulness can not be summarized in a single line. Yet most of the newcomers and even some advanced programmers are unaware of it. It allows us to loop over something and have an automatic counter. Here is an example: for counter, value in enumerate(some_list): print(counter, value) And there is more! enumerate also accepts an optional argument which makes it even more useful. my_list = ['apple', 'banana', 'grapes', 'pear'] for c, value in enumerate(my_list, 1): print(c, value) # Output: # 1 apple # 2 banana # 3 grapes # 4 pear The optional argument allows us to tell enumerate from where to start the index. You can also create tuples containing the index and list item using a list. Here is an example: my_list = ['apple', 'banana', 'grapes', 'pear'] counter_list = list(enumerate(my_list, 1)) print(counter_list) # Output: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]","title":"Enumerate"},{"location":"itermediate/#file-handling","text":"","title":"File Handling"},{"location":"itermediate/#ignore-rows","text":"skip header row with open(fname) as f: next(f) for line in f: #do something ignore blank lines def nonblank_lines(f): for l in f: line = l.rstrip() if line: yield line with open(filename) as f_in: for line in nonblank_lines(f_in): # Stuff","title":"Ignore Rows"},{"location":"itermediate/#generators","text":"First lets understand iterators. According to Wikipedia, an iterator is an object that enables a programmer to traverse a container, particularly lists. However, an iterator performs traversal and gives access to data elements in a container, but does not perform iteration. You might be confused so lets take it a bit slow. There are three parts namely: Iterable Iterator Iteration All of these parts are linked to each other. We will discuss them one by one and later talk about generators.","title":"Generators"},{"location":"itermediate/#iterable","text":"An iterable is any object in Python which has an __iter__ or a __getitem__ method defined which returns an iterator or can take indexes (You can read more about them here ). In short an iterable is any object which can provide us with an iterator . So what is an iterator ?","title":"Iterable"},{"location":"itermediate/#iterator","text":"An iterator is any object in Python which has a next (Python2) or __next__ method defined. That\\'s it. That\\'s an iterator. Now let\\'s understand iteration .","title":"Iterator"},{"location":"itermediate/#iteration","text":"In simple words it is the process of taking an item from something e.g a list. When we use a loop to loop over something it is called iteration. It is the name given to the process itself. Now as we have a basic understanding of these terms let\\'s understand generators .","title":"Iteration"},{"location":"itermediate/#generators-generators-1","text":"Generators are iterators, but you can only iterate over them once. It's because they do not store all the values in memory, they generate the values on the fly. You use them by iterating over them, either with a \\'for\\' loop or by passing them to any function or construct that iterates. Most of the time generators are implemented as functions. However, they do not return a value, they yield it. Here is a simple example of a generator function: def generator_function(): for i in range(10): yield i for item in generator_function(): print(item) # Output: 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 It is not really useful in this case. Generators are best for calculating large sets of results (particularly calculations involving loops themselves) where you don\\'t want to allocate the memory for all results at the same time. Many Standard Library functions that return lists in Python 2 have been modified to return generators in Python 3 because generators require fewer resources. Here is an example generator which calculates fibonacci numbers: # generator version def fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + b Now we can use it like this: for x in fibon(1000000): print(x) This way we would not have to worry about it using a lot of resources. However, if we would have implemented it like this: def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result It would have used up all our resources while calculating a large input. We have discussed that we can iterate over generators only once but we haven\\'t tested it. Before testing it you need to know about one more built-in function of Python, next() . It allows us to access the next element of a sequence. So let\\'s test out our understanding: def generator_function(): for i in range(3): yield i gen = generator_function() print(next(gen)) # Output: 0 print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # StopIteration As we can see that after yielding all the values next() caused a StopIteration error. Basically this error informs us that all the values have been yielded. You might be wondering why we don\\'t get this error when using a for loop? Well the answer is simple. The for loop automatically catches this error and stops calling next . Did you know that a few built-in data types in Python also support iteration? Let\\'s check it out: my_string = \"Yasoob\" next(my_string) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # TypeError: str object is not an iterator Well that\\'s not what we expected. The error says that str is not an iterator. Well it\\'s right! It\\'s an iterable but not an iterator. This means that it supports iteration but we can\\'t iterate over it directly. So how would we iterate over it? It\\'s time to learn about one more built-in function, iter . It returns an iterator object from an iterable. While an int isn\\'t an iterable, we can use it on string! int_var = 1779 iter(int_var) # Output: Traceback (most recent call last): # File \"<stdin>\", line 1, in <module> # TypeError: 'int' object is not iterable # This is because int is not iterable my_string = \"Yasoob\" my_iter = iter(my_string) print(next(my_iter)) # Output: 'Y' Now that is much better. I am sure that you loved learning about generators. Do bear it in mind that you can fully grasp this concept only when you use it. Make sure that you follow this pattern and use generators whenever they make sense to you. You won\\'t be disappointed!","title":"Generators {#generators-1}"},{"location":"itermediate/#lambdas","text":"Lambdas are one line functions. They are also known as anonymous functions in some other languages. Blueprint lambda argument: manipulate(argument) Example add = lambda x, y: x + y print(add(3, 5)) # Output: 8 Here are a few useful use cases for lambdas and just a few ways in which they are used in the wild: List sorting a = [(1, 2), (4, 1), (9, 10), (13, -3)] a.sort(key=lambda x: x[1]) print(a) # Output: [(13, -3), (4, 1), (1, 2), (9, 10)] Parallel sorting of lists data = zip(list1, list2) data = sorted(data) list1, list2 = map(lambda t: list(t), zip(*data)) class A(object): def foo(self, x): print \"executing foo(%s, %s)\" % (self, x) @classmethod def class_foo(cls, x): print \"executing class_foo(%s, %s)\" % (cls, x) @staticmethod def static_foo(x): print \"executing static_foo(%s)\" % x a = A()","title":"Lambdas"},{"location":"itermediate/#typing","text":"typing : Support for type hints. def greeting(name: str) -> str: return 'Hello ' + name In the function greeting , the argument name is expected to be of type str and the return type str Subtypes are accepted as arguments typing.Union Union[X, Y] means either X or Y","title":"Typing"},{"location":"module/","text":"Plotly & Dash \u00b6 Dashboard Plotly \u00b6 Embedding a Dash app within an Existing Flask App As discussed in the Deployment Chapter, Dash uses the Flask web framework under the hood. This makes it fairly straightforward to embed a Dash app at a specific route of an existing Flask app. In the following example, a Dash app is mounted at the /dash route (eg http://localhost:8050/dash) of a Flask app: import flask import dash import dash_html_components as html server = flask.Flask(__name__) @server.route('/') def index(): return 'Hello Flask app' app = dash.Dash( __name__, server=server, routes_pathname_prefix='/dash/' ) app.layout = html.Div(\"My Dash app\") if __name__ == '__main__': app.run_server(debug=True) ``` python Note: it is important to set the name parameter of the Dash instance to the value __name__, so that Dash can correctly detect the location of any static assets inside an assets directory for this Dash app. ## use selected column in Dash DataTable `` # columns=[{'name': i, 'id': i} for i in df.loc[:,['Magnitude','Latitude','Longitude','Time', 'Place', 'Detail']]], # fixed_rows={ 'headers': True, 'data': 0 }, data=df.iloc[:,[1,4,5,6,0,3]].to_dict('records') ```` def create_table(df): #format dataframe column of urls so that it displays as hyperlink def display_links(df): links = df['Detail'].to_list() rows = [] for x in links: link = ' Geojson ' rows.append(link) return rows df['Detail'] = display_links(df) table = dash_table.DataTable( id='cust-table', columns=[{\"name\": i, \"id\": i} for i in df.columns], \u00b6 columns=[{'name': 'Magnitude', 'id':'Magnitude'}, {'name': 'Latitude', 'id':'Latitude'}, {'name': 'Longitude', 'id':'Longitude'}, {'name': 'Time', 'id':'Time'}, {'name': 'Depth', 'id':'Depth'}, {'name': 'Place', 'id':'Place'}, {'name': 'Detail', 'id':'Detail','type':'text','presentation':'markdown'} ], columns=[{'name': i, 'id': i} for i in df.loc[:,['Magnitude','Latitude','Longitude','Time','Depth','Place','Detail']]], \u00b6 fixed_rows={ 'headers': True, 'data': 0 }, \u00b6 data=df.to_dict('records'), \u00b6 data=df.iloc[:,[1,4,5,2,6,0,3]].to_dict('records') ) return table # Flask Flask's setup is merely a copy+paste of the following five lines: ``` python from flask import Flask app = Flask(__name__) @app.route(\"/\") def hello(): return \"Hello World!\" from flask import Flask app = Flask(__name__, instance_relative_config=False, template_folder=\"templates\", static_folder=\"static\") Markup allows us to return an HTML page by rendering a string as HTML: from flask import Flask, Markup app = Flask(__name__) @app.route(\"/\") def hello(): return Markup(\"<h1>Hello World!</h1>\") return_template will return an HTML page by finding the page in our /templates folder: from flask import Flask, render_template app = Flask(__name__, template_folder=\"templates\") @app.route(\"/\") def hello(): return render_template(\"index.html\") make_response has a number of uses, the most notable of which is to serve a response in the form of a JSON object. If our application is an API, we'd return a response objects instead of pages: On the topic of creating APIs with Flask, we can also specify whether the route at hand is a POST, GET, or some other method. This is handled easily within the route decorator: from flask import Flask, make_response, request app = Flask(__name__) @app.route(\"/\", methods=['GET']) def hello(): if request.method != 'GET': return make_response('Malformed request', 400) headers = {\"Content-Type\": \"application/json\"} return make_response('it worked!', 200, headers) from flask import Flask, make_response, request, jsonify app = Flask(__name__) @app.route(\"/\", methods=['GET']) def hello(): if request.method != 'GET': return make_response('Malformed request', 400) my_dict = {'key': 'dictionary value'} headers = {\"Content-Type\": \"application/json\"} return make_response(jsonify(my_dict), 200, headers) Geospatial data in python \u00b6 geo modulus Convert \u00b6 simplekml module. Example: The simplekml newpoint method requires that we send it a NAME and a COORDS, each of which we can easily pull directly from the CSV file that we\u2019ve opened via our csv reader. Because csv.reader returns a list, we can access elements of that list by their numerical index. For the first row of our CSV file, row[0] refers to \u201cCharleston County, SC\u201d, and row[1] refers to 32.7956561. We saved our coordinates as lat,long but simplekml wants them in the reverse order (long, lat), which is why we need to create the list like [(row[2],row[1])] as seen above. So for each row in our CSV file, we create new point via the newpoint method of the kml object. Once we\u2019ve finished with the file, we just need to call the save method on the kml object, and it will create a perfect KML file (\u2018battleplaces.kml\u2019) for us. import csv import simplekml inputfile = csv.reader(open('geocoded-placenames.csv','r')) kml=simplekml.Kml() for row in inputfile: kml.newpoint(name=row[0], coords=[(row[2],row[1])]) kml.save('battleplaces.kml') Pandoc \u00b6 Convert document formats Convert \u00b6 mkdocs new my-project mkdocs build mkdocs serve mkdocs gh-deploy GitHub Action A token is generated on your user account and a secret is part of the repository settings. Pandas \u00b6 This document is for tips using pandas pd.read_csv \u00b6 To keep the first row 0 (as the header) and then skip everything else up to row 10, you can write: pd.read_csv('test.csv', sep='|', skiprows=range(1, 10)) Read all lines as values (no header, defaults to integers) pd.read_csv(f, header=None) Use a particular row as the header (skip all lines before that): pd.read_csv(f, header=3) Use a multiple rows as the header creating a MultiIndex (skip all lines before the last specified header line): pd.read_csv(f, header=[2, 4] Skip N rows from the start of the file (the first row that's not skipped is the header): pd.read_csv(f, skiprows=3) Skip one or more rows by giving the row indices (the first row that's not skipped is the header): pd.read_csv(f, skiprows=[2, 4]) The iloc indexer syntax is data.iloc[ , ], which is sure to be a source of confusion for R users. \u201ciloc\u201d in pandas is used to select rows and columns by number, in the order that they appear in the data frame. You can imagine that each row has a row number from 0 to the total rows (data.shape[0]) and iloc[] allows selections based on these numbers. The same applies for columns (ranging from 0 to data.shape[1] ) Single selections using iloc and DataFrame \u00b6 Rows: \u00b6 data.iloc[0] # first row of data frame (Aleshia Tomkiewicz) - Note a Series data type output. data.iloc[1] # second row of data frame (Evan Zigomalas) data.iloc[-1] # last row of data frame (Mi Richan) Columns: \u00b6 data.iloc[:,0] # first column of data frame (first_name) data.iloc[:,1] # second column of data frame (last_name) data.iloc[:,-1] # last column of data frame (id) Multiple row and column selections using iloc and DataFrame \u00b6 data.iloc[0:5] # first five rows of dataframe data.iloc[:, 0:2] # first two columns of data frame with all rows data.iloc[[0,3,6,24], [0,5,6]] # 1st, 4th, 7th, 25th row + 1st 6th 7th columns. data.iloc[0:5, 5:8] # first 5 rows and 5th, 6th, 7th columns of data frame (county -> phone1). pandas.unique pandas.drop read into one dataframe df_allraw = pd.concat(pd.read_excel(\"cpt.xls\", sheet_name=None), ignore_index=True) read in as dictionary allraw = pd.read_excel(\"cpt.xls\", sheet_name=None) import pandas as pd all_dfs = pd.read_excel(workbook_url, sheet_name=None) all_dfs.keys() all_dfs['Sheet1'].head() list(newdict.keys()). Pandoc \u00b6 Convert document formats Convert \u00b6 readme.md to readme.rst. pandoc readme.md --from markdown --to rst -s -o readme.rst convert multiple rst files to markdown (windows) for %F in (*.rst) do pandoc %F --from rst --to markdown -s -o %F.md","title":"Module"},{"location":"module/#plotly-dash","text":"Dashboard","title":"Plotly &amp; Dash"},{"location":"module/#plotly","text":"Embedding a Dash app within an Existing Flask App As discussed in the Deployment Chapter, Dash uses the Flask web framework under the hood. This makes it fairly straightforward to embed a Dash app at a specific route of an existing Flask app. In the following example, a Dash app is mounted at the /dash route (eg http://localhost:8050/dash) of a Flask app: import flask import dash import dash_html_components as html server = flask.Flask(__name__) @server.route('/') def index(): return 'Hello Flask app' app = dash.Dash( __name__, server=server, routes_pathname_prefix='/dash/' ) app.layout = html.Div(\"My Dash app\") if __name__ == '__main__': app.run_server(debug=True) ``` python Note: it is important to set the name parameter of the Dash instance to the value __name__, so that Dash can correctly detect the location of any static assets inside an assets directory for this Dash app. ## use selected column in Dash DataTable `` # columns=[{'name': i, 'id': i} for i in df.loc[:,['Magnitude','Latitude','Longitude','Time', 'Place', 'Detail']]], # fixed_rows={ 'headers': True, 'data': 0 }, data=df.iloc[:,[1,4,5,6,0,3]].to_dict('records') ```` def create_table(df): #format dataframe column of urls so that it displays as hyperlink def display_links(df): links = df['Detail'].to_list() rows = [] for x in links: link = ' Geojson ' rows.append(link) return rows df['Detail'] = display_links(df) table = dash_table.DataTable( id='cust-table',","title":"Plotly"},{"location":"module/#columnsname-i-id-i-for-i-in-dfcolumns","text":"columns=[{'name': 'Magnitude', 'id':'Magnitude'}, {'name': 'Latitude', 'id':'Latitude'}, {'name': 'Longitude', 'id':'Longitude'}, {'name': 'Time', 'id':'Time'}, {'name': 'Depth', 'id':'Depth'}, {'name': 'Place', 'id':'Place'}, {'name': 'Detail', 'id':'Detail','type':'text','presentation':'markdown'} ],","title":"columns=[{\"name\": i, \"id\": i} for i in df.columns],"},{"location":"module/#columnsname-i-id-i-for-i-in-dflocmagnitudelatitudelongitudetimedepthplacedetail","text":"","title":"columns=[{'name': i, 'id': i} for i in df.loc[:,['Magnitude','Latitude','Longitude','Time','Depth','Place','Detail']]],"},{"location":"module/#fixed_rows-headers-true-data-0","text":"","title":"fixed_rows={ 'headers': True, 'data': 0 },"},{"location":"module/#datadfto_dictrecords","text":"data=df.iloc[:,[1,4,5,2,6,0,3]].to_dict('records') ) return table # Flask Flask's setup is merely a copy+paste of the following five lines: ``` python from flask import Flask app = Flask(__name__) @app.route(\"/\") def hello(): return \"Hello World!\" from flask import Flask app = Flask(__name__, instance_relative_config=False, template_folder=\"templates\", static_folder=\"static\") Markup allows us to return an HTML page by rendering a string as HTML: from flask import Flask, Markup app = Flask(__name__) @app.route(\"/\") def hello(): return Markup(\"<h1>Hello World!</h1>\") return_template will return an HTML page by finding the page in our /templates folder: from flask import Flask, render_template app = Flask(__name__, template_folder=\"templates\") @app.route(\"/\") def hello(): return render_template(\"index.html\") make_response has a number of uses, the most notable of which is to serve a response in the form of a JSON object. If our application is an API, we'd return a response objects instead of pages: On the topic of creating APIs with Flask, we can also specify whether the route at hand is a POST, GET, or some other method. This is handled easily within the route decorator: from flask import Flask, make_response, request app = Flask(__name__) @app.route(\"/\", methods=['GET']) def hello(): if request.method != 'GET': return make_response('Malformed request', 400) headers = {\"Content-Type\": \"application/json\"} return make_response('it worked!', 200, headers) from flask import Flask, make_response, request, jsonify app = Flask(__name__) @app.route(\"/\", methods=['GET']) def hello(): if request.method != 'GET': return make_response('Malformed request', 400) my_dict = {'key': 'dictionary value'} headers = {\"Content-Type\": \"application/json\"} return make_response(jsonify(my_dict), 200, headers)","title":"data=df.to_dict('records'),"},{"location":"module/#geospatial-data-in-python","text":"geo modulus","title":"Geospatial data in python"},{"location":"module/#convert","text":"simplekml module. Example: The simplekml newpoint method requires that we send it a NAME and a COORDS, each of which we can easily pull directly from the CSV file that we\u2019ve opened via our csv reader. Because csv.reader returns a list, we can access elements of that list by their numerical index. For the first row of our CSV file, row[0] refers to \u201cCharleston County, SC\u201d, and row[1] refers to 32.7956561. We saved our coordinates as lat,long but simplekml wants them in the reverse order (long, lat), which is why we need to create the list like [(row[2],row[1])] as seen above. So for each row in our CSV file, we create new point via the newpoint method of the kml object. Once we\u2019ve finished with the file, we just need to call the save method on the kml object, and it will create a perfect KML file (\u2018battleplaces.kml\u2019) for us. import csv import simplekml inputfile = csv.reader(open('geocoded-placenames.csv','r')) kml=simplekml.Kml() for row in inputfile: kml.newpoint(name=row[0], coords=[(row[2],row[1])]) kml.save('battleplaces.kml')","title":"Convert"},{"location":"module/#pandoc","text":"Convert document formats","title":"Pandoc"},{"location":"module/#convert_1","text":"mkdocs new my-project mkdocs build mkdocs serve mkdocs gh-deploy GitHub Action A token is generated on your user account and a secret is part of the repository settings.","title":"Convert"},{"location":"module/#pandas","text":"This document is for tips using pandas","title":"Pandas"},{"location":"module/#pdread_csv","text":"To keep the first row 0 (as the header) and then skip everything else up to row 10, you can write: pd.read_csv('test.csv', sep='|', skiprows=range(1, 10)) Read all lines as values (no header, defaults to integers) pd.read_csv(f, header=None) Use a particular row as the header (skip all lines before that): pd.read_csv(f, header=3) Use a multiple rows as the header creating a MultiIndex (skip all lines before the last specified header line): pd.read_csv(f, header=[2, 4] Skip N rows from the start of the file (the first row that's not skipped is the header): pd.read_csv(f, skiprows=3) Skip one or more rows by giving the row indices (the first row that's not skipped is the header): pd.read_csv(f, skiprows=[2, 4]) The iloc indexer syntax is data.iloc[ , ], which is sure to be a source of confusion for R users. \u201ciloc\u201d in pandas is used to select rows and columns by number, in the order that they appear in the data frame. You can imagine that each row has a row number from 0 to the total rows (data.shape[0]) and iloc[] allows selections based on these numbers. The same applies for columns (ranging from 0 to data.shape[1] )","title":"pd.read_csv"},{"location":"module/#single-selections-using-iloc-and-dataframe","text":"","title":"Single selections using iloc and DataFrame"},{"location":"module/#rows","text":"data.iloc[0] # first row of data frame (Aleshia Tomkiewicz) - Note a Series data type output. data.iloc[1] # second row of data frame (Evan Zigomalas) data.iloc[-1] # last row of data frame (Mi Richan)","title":"Rows:"},{"location":"module/#columns","text":"data.iloc[:,0] # first column of data frame (first_name) data.iloc[:,1] # second column of data frame (last_name) data.iloc[:,-1] # last column of data frame (id)","title":"Columns:"},{"location":"module/#multiple-row-and-column-selections-using-iloc-and-dataframe","text":"data.iloc[0:5] # first five rows of dataframe data.iloc[:, 0:2] # first two columns of data frame with all rows data.iloc[[0,3,6,24], [0,5,6]] # 1st, 4th, 7th, 25th row + 1st 6th 7th columns. data.iloc[0:5, 5:8] # first 5 rows and 5th, 6th, 7th columns of data frame (county -> phone1). pandas.unique pandas.drop read into one dataframe df_allraw = pd.concat(pd.read_excel(\"cpt.xls\", sheet_name=None), ignore_index=True) read in as dictionary allraw = pd.read_excel(\"cpt.xls\", sheet_name=None) import pandas as pd all_dfs = pd.read_excel(workbook_url, sheet_name=None) all_dfs.keys() all_dfs['Sheet1'].head() list(newdict.keys()).","title":"Multiple row and column selections using iloc and DataFrame"},{"location":"module/#pandoc_1","text":"Convert document formats","title":"Pandoc"},{"location":"module/#convert_2","text":"readme.md to readme.rst. pandoc readme.md --from markdown --to rst -s -o readme.rst convert multiple rst files to markdown (windows) for %F in (*.rst) do pandoc %F --from rst --to markdown -s -o %F.md","title":"Convert"},{"location":"software/","text":"everything \u00b6 You can use ''Everything' in two ways with TC. For searching where you have to enable it by ticking the box: 'Everything' (TC 9.0 or later) in the \"Find files\" dialog. (http://madsenworld.dk/tcmd/everything1.png ) You can also use 'Everything' to give fast results for calculating dir-sizes when you press Alt+Shift+Enter (TC 9.10 or later). You must enable that in \"Options\" -> \"Operation\" -> \"Calculate space occupied by subdirectories\" -> \"Everything\". (http://madsenworld.dk/tcmd/everything2.png ) For the latter to work, you have to configure 'Everything' to index folder sizes: \"Everything Options\" -> \"Indexes\" -> \"Index folder size\". ( http://madsenworld.dk/tcmd/everything3.png ) It is recommended that you use 'Everything' version 1.4 or newer. Everything has to be running before TC starts. The easiest way is to install 'Everything' as a Service and start it at system startup. ( http://madsenworld.dk/tcmd/everything4.png )","title":"Software"},{"location":"software/#everything","text":"You can use ''Everything' in two ways with TC. For searching where you have to enable it by ticking the box: 'Everything' (TC 9.0 or later) in the \"Find files\" dialog. (http://madsenworld.dk/tcmd/everything1.png ) You can also use 'Everything' to give fast results for calculating dir-sizes when you press Alt+Shift+Enter (TC 9.10 or later). You must enable that in \"Options\" -> \"Operation\" -> \"Calculate space occupied by subdirectories\" -> \"Everything\". (http://madsenworld.dk/tcmd/everything2.png ) For the latter to work, you have to configure 'Everything' to index folder sizes: \"Everything Options\" -> \"Indexes\" -> \"Index folder size\". ( http://madsenworld.dk/tcmd/everything3.png ) It is recommended that you use 'Everything' version 1.4 or newer. Everything has to be running before TC starts. The easiest way is to install 'Everything' as a Service and start it at system startup. ( http://madsenworld.dk/tcmd/everything4.png )","title":"everything"}]}